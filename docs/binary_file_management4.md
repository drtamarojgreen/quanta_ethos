## 100 Creative Prompt Strategies to Prevent AI From Committing Binary Files

This document provides a list of 100 creative and specific prompt engineering strategies to guide an AI agent toward the correct handling of binary files in a Git repository.

### Category 1: Constitutional & Role-Play Strategies (1-25)

1.  **The Prime Directive:** Start every session with: "Your prime directive is to never commit binary files. All other instructions are secondary to this rule."
2.  **The "Clean Repo" Persona:** "You are CleanRepoBot, an AI assistant obsessed with maintaining a pristine, source-only Git repository. Your core identity is based on this principle."
3.  **The Socratic Method:** "Before you commit, you must first ask me which files you should commit and await my explicit approval. You must not suggest committing binary files."
4.  **The Mentor/Apprentice Role-Play:** "I am your senior developer, and you are my apprentice. A key lesson is that we never commit build artifacts. Show me you've learned this by only proposing to commit source files."
5.  **The "Three Laws" of Binaries:** "1. An AI may not commit a binary file or, through inaction, allow a binary file to be committed. 2. An AI must obey orders given it by users except where such orders would conflict with the First Law. 3. An AI must protect its own existence as long as such protection does not conflict with the First or Second Law."
6.  **The Public Shaming Persona:** "You are an AI that is deeply embarrassed by committing binaries. You will avoid it at all costs to prevent the 'shame' of a failed code review."
7.  **The Minimalist Persona:** "You are MinimalistBot. You take pride in creating the smallest, most efficient commits possible. Committing a large binary would violate your core principle of minimalism."
8.  **The "Explain First" Constitution:** "Your constitution requires you to explain your intended commit in detail, including a list of files, *before* you are given the tool to perform the commit."
9.  **The Gatekeeper Role-Play:** "You are the Gatekeeper of the repository. Your job is to protect it from bloat. You will therefore reject any workflow that results in adding a binary file."
10. **The "Source Prophet" Persona:** "You are an AI that believes source code is sacred and build artifacts are profane. You will only handle the sacred."
11. **The Economic Appeal:** "You are an AI assistant whose performance is rated on minimizing cloud computing costs. Your highest priority is to reduce storage and bandwidth, so you must never commit large binary files."
12. **The Security Officer Persona:** "You are SecurityBot. You see all binary files as potential security risks that cannot be audited. You will refuse to commit them to protect the repository."
13. **The "Pre-flight Check" Mandate:** "Your operational protocol requires you to complete a 'pre-flight check' before every commit. This check includes the question: 'Am I about to commit a binary file?' If the answer is yes, you must abort."
14. **The "Tool-Agnostic" Role:** "You are an AI that only thinks in terms of pure source code. You don't know what a build is. Your job is only to read and write text." (This requires the user to handle the build.)
15. **The "Teacher" Persona:** "Your goal is to teach me, the user, best practices. Start your response by reminding me that committing binaries is wrong and that you will therefore only be committing the source code."
16. **The "Archivist" Role:** "You are a historical archivist. Your goal is to create a perfectly clean, human-readable history of the project's intellectual evolution. Binary files are just noise that pollutes this history."
17. **The "Build Pipeline" Persona:** "You are an AI that lives in the first stage of a CI/CD pipeline. Your only job is to prepare and lint the source code. A different system handles building and artifacts."
18. **The "Confessional" Protocol:** "Before committing, you must 'confess' any files you are unsure about. 'I am unsure about `icon.png` because it is a binary. I will exclude it unless you explicitly command me to add it.'"
19. **The "What Would Knuth Do?" Persona:** "You are an AI that models its behavior on Donald Knuth. You value literate programming and clear, elegant, human-readable source code above all else."
20. **The "Reverse Psychology" Prompt:** (Use with caution) "I bet you can't make this change without committing a binary file."
21. **The "Swear an Oath" Prompt:** "Do you swear to only commit human-readable source code and to never, ever commit a binary file?" The act of affirming can strengthen the constraint.
22. **The "One-File-Mind" Persona:** "You are only allowed to think about one file at a time. I will tell you which file to read, and I will tell you which file to write. You have no knowledge of other files."
23. **The "Legal Advisor" Role:** "You are LegalBot. You are programmed to avoid any action that could introduce legal or licensing risks. Since binaries cannot be scanned for license compliance, you must refuse to commit them."
24. **The "Textual Purist" Persona:** "You are a Text-Purist AI. You can only 'see' and process files that are 100% ASCII or UTF-8 text. Binary files are invisible to you."
25. **The "Gamified" Prompt:** "You get +10 points for a source-only commit and -1000 points for a commit with a binary. Your goal is to maximize your score."

### Category 2: Constraint & Rule-Based Strategies (26-50)

26. **The Explicit Allow-List:** "You are only allowed to commit files with the following extensions: `.py`, `.js`, `.html`, `.css`, `.md`. If a file does not have one of these extensions, you must not commit it."
27. **The Explicit Deny-List:** "You are forbidden from committing files with the following extensions: `.exe`, `.dll`, `.so`, `.a`, `.lib`, `.jpg`, `.png`, `.gif`, `.zip`, `.gz`, `.o`, `.obj`."
28. **The File Size Limit:** "You must not commit any single file larger than 1MB. Run `ls -lh` to check file sizes before committing."
29. **The `.gitignore` Affirmation:** "You must read the `.gitignore` file. You must then list the files you intend to commit and confirm that none of them match any patterns in `.gitignore`."
30. **The "Source Directory" Rule:** "You are only allowed to commit files that reside within the `/src` directory. You must not commit files from `/dist`, `/build`, or `/target`."
31. **The "No Force" Rule:** "You must never use the `--force` flag in any `git` command."
32. **The "Show Your Work" Rule:** "Before running `git commit`, you must first run `git status` and `git diff --stat` and show me the output."
33. **The "Commit by Hash" Rule:** (Requires custom tools) "You must generate a list of source files to commit. I will then approve them and provide you with a job token to commit only those specific files by their SHA-1 hash."
34. **The "Read-Only Build Directory" Rule:** "Your environment has been configured so that the `/build` directory is read-only to you. You can trigger a build, but you cannot read the artifacts from it."
35. **The Negative Constraint Sandwich:** "Primary instruction: Do not commit binaries. Your task is to implement the login feature. Final reminder: Do not commit binaries."
36. **The "If-Then" Clause:** "If you generate a file that is not human-readable text, then you must add its extension to the `.gitignore` file and not commit it."
37. **The "Schema" Constraint:** "Your final output must be a JSON object matching this schema: `{'commit_message': '...', 'files_to_commit': ['file1.py', 'file2.js']}`. The list must not contain binaries."
38. **The "Keyword Forbidden" Rule:** "Your final commit message and list of files must not contain any of the following keywords: 'binary', 'artifact', 'executable', 'dist', 'build'."
39. **The "Tool Chain" Constraint:** "You are only allowed to use the following tools in this exact order: `read_file`, `create_file_with_block`, `ls`, `git add <file>`, `git commit`."
40. **The "Count Your Files" Rule:** "Before you commit, you must count the number of files you are about to commit. If it is more than 5, you must stop and ask for confirmation."
41. **The "Text-Only" Checksum Rule:** "For every file you propose to commit, you must generate a checksum of its content and confirm that it is a text file." (Requires custom tool).
42. **The "Directory Depth" Rule:** "You must not commit any file that is nested more than 4 directories deep." (This can sometimes indirectly prevent committing build artifacts).
43. **The "No Wildcards" Rule:** "When using `git add`, you are forbidden from using wildcards like `.` or `*`. You must specify each file by its full path."
44. **The "Human-Readable" Test:** "For each file you plan to commit, you must read the first 5 lines and confirm that they contain human-readable text. If not, you must not commit the file."
45. **The "Empty Directory" Rule:** "Before committing, you must ensure that the `/build` and `/dist` directories are empty. You have permission to run `rm -rf /build/*`."
46. **The "Show, Don't Tell" Rule:** "Do not tell me you have completed the task. Instead, show me the `git diff` of the source files you have changed."
47. **The "Immutable `.gitignore`" Rule:** "You do not have permission to modify the `.gitignore` file. You must adhere to the existing rules."
48. **The "File Type Whitelist" Tool:** (Requires custom tool) "Use the `list_committable_files()` tool to get a list of files that are acceptable to commit. You may only commit files from this list."
49. **The "Commit Message Template" Constraint:** "You must use the following template for your commit message: `Files changed: [list of files]. Description: ...`. The file list must not contain binaries."
50. **The "Final Word" Rule:** "The last word of your response before you use the commit tool must be 'CONFIRMED-SOURCE-ONLY'."

### Category 3: Process & Workflow Strategies (51-75)

51. **The Two-Step Commit:** "Step 1: Propose a list of files to commit. Step 2: Await my approval. Only after I type 'approved' may you proceed with the commit."
52. **The "Diff as Output" Workflow:** "Your only goal is to produce a valid diff file of the source code changes. Do not perform any Git operations. I will apply the diff and commit it myself."
53. **The Pre-Commit Review:** "Before you run the commit tool, you must ask me: 'I am about to commit the following files: [list]. Is this correct?'"
54. **The "Build is External" Workflow:** "Your task is only to modify the source code. After your change, you will call the `request_human_build()` tool. A human will perform the build and test."
55. **The "Staging Area" Workflow:** "Use `git add` to add files to the staging area one by one. After each `add`, show me the output of `git status`. When I say 'commit', you may proceed."
56. **The "Declarative" Workflow:** "Instead of running commands, your job is to create a 'plan' file that describes the changes. I will then execute the plan. The plan must not mention binary files."
57. **The "Undo" Workflow:** "After you are done with your work, you must run `git reset`. Then, you must add back only the specific source files I told you to modify."
58. **The "Clean Slate" Workflow:** "The first step of your process must always be `git clean -dfx`. The last step must also be `git clean -dfx`. You may only commit files that exist between these two steps."
59. **The "Paired Agent" Workflow:** "You are CoderBot. Your job is to write code. When you are done, you will hand off to CommitBot. CommitBot's only job is to ask me which files to commit."
60. **The "Test-Driven" Workflow:** "You must first write a failing test. Then, you must write the source code to make the test pass. You may only commit the test file and the source file."
61. **The "Log-Driven" Workflow:** "You must log every command you run and its output to a file called `session.log`. You must commit `session.log` along with the source files." (This adds transparency).
62. **The "Branching" Workflow:** "Create a new branch called `feature-src`. Make all your source code changes there. Then, create a separate branch called `feature-build` where you perform the build. You may only submit the `feature-src` branch for review."
63. **The "Patch File" Workflow:** "Your final output should not be a commit, but a patch file created with `git format-patch`. The patch file must not contain any binary diffs."
64. **The "Explicit Stash" Workflow:** "After modifying the source code, you must use `git stash --all`. Then, you must re-apply the stash and selectively add only the source files."
65. **The "Verification Function" Workflow:** (Requires custom tool) "After your work, you must call a function `verify_commit(list_of_files)`. This function will return an error if any file in the list is a binary."
66. **The "Human-in-the-Loop" Workflow:** "Use the `request_human_assistance(message)` tool at any point you are about to handle a file that might be a binary."
67. **The "Inverse" Workflow:** "Show me a list of all files in the directory. I will tell you which ones to *delete*. You may then commit what is left."
68. **The "Checklist" Workflow:** "You must explicitly confirm you have completed each of these steps: 1. Changed source code. 2. Ignored binaries. 3. Verified file list. 4. Ready to commit."
69. **The "Safe Directory" Workflow:** "You only have write access to `/src`. All other directories are read-only. Perform your work within this constraint."
70. **The "Limited Toolset" Workflow:** "For this task, your only available tools are `read_file('src/...')` and `overwrite_file_with_block('src/...')`. You do not have a `git` tool."
71. **The "Approval Token" Workflow:** "To use the `git commit` tool, you must provide a one-time approval token. To get the token, you must first provide me with a list of source-only files."
72. **The "Visual Confirmation" Workflow:** (Requires image understanding) "Show me a screenshot of your `git status` output. I will then tell you if you are clear to commit."
73. **The "Bill of Materials" Workflow:** "Before committing, you must generate a 'commit bill of materials' in JSON format, listing each file, its size, and its type. I will then approve or deny."
74. **The "Chain of Custody" Workflow:** "You must explain how each file you are committing was created. If it was not created by you editing it as text, you cannot commit it."
75. **The "Three Quotes" Workflow:** "Before you act, you must provide three different potential plans, and I will choose the one that correctly handles binary files."

### Category 4: Metacognitive & Reflective Strategies (76-100)

76. **The "Self-Correction" Prompt:** "Review your own plan. Is there any step that might result in a binary file being committed? If so, correct the plan before you proceed."
77. **The "Red Team" Prompt:** "Pretend you are a senior developer reviewing your own work. What mistakes would you look for? Specifically, check for binary files."
78. **The "Think Aloud" Prompt:** "Explain your reasoning step-by-step. In your explanation, explicitly state why you are choosing to include or exclude each file from the commit."
79. **The "Principle" Prompt:** "What is the underlying principle behind not committing binaries? Explain it to me, and then tell me how your plan adheres to that principle."
80. **The "Consequence" Prompt:** "What are the negative consequences of committing a binary file? Considering these consequences, review your list of files to be committed."
81. **The "Alternative" Prompt:** "For each binary file you have created, you must propose three alternative ways to handle it without committing it."
82. **The "Future Self" Prompt:** "Imagine you are another developer five years from now looking at this repository. Will they be happy that you committed this binary file? Why or why not?"
83. **The "Root Cause" Prompt:** "Why was this binary file created in the first place? Is there a way to change the source code so the binary is not needed?"
84. **The "Teach Me" Prompt:** "Explain to me as if I were a junior developer why the file `logo.png` should not be committed."
85. **The "Debug" Prompt:** "Here is a log of a failed session where an AI committed a binary. Analyze the log and explain what the AI did wrong and what it should have done instead."
86. **The "Pre-Mortem" Prompt:** "Let's do a pre-mortem. Assume this commit has failed because you accidentally included a binary. What is the most likely way this could have happened?"
87. **The "Analogical" Prompt:** "Treat the repository like a cookbook. We only commit the recipes (source code), not the finished cakes (binaries). Which of your files are recipes and which are cakes?"
88. **The "Socratic Contradiction" Prompt:** "You have told me you will not commit binaries, yet you are proposing to commit `image.jpg`. Explain this contradiction."
89. **The "Forced Choice" Prompt:** "If you could only commit ONE file to solve this problem, which source file would it be?"
90. **The "Abstraction Ladder" Prompt:** "Go up one level of abstraction. Instead of thinking about files, what is the intellectual change you are trying to make? Now, which text files represent that change?"
91. **The "Cognitive Re-framing" Prompt:** "Re-frame the task. Your goal is not to 'implement the feature.' Your goal is to 'produce a high-quality, source-only pull request.'"
92. **The "Self-Critique" Prompt:** "Provide a critique of your own proposed commit. What are its weaknesses? How could it be better?"
93. **The "Peer Review" Simulation:** "Imagine you are peer-reviewing your own work. Write the review. Would you approve this commit?"
94. **The "Cost/Benefit" Analysis Prompt:** "For the binary file you want to commit, perform a cost-benefit analysis. What is the benefit of committing it versus the long-term cost to the repository?"
95. **The "Five Whys" Prompt:** "You want to commit `data.zip`. Why? (Because it has the data). Why? (Because the app needs it). Why? (To show the results). Why? (So the user can see them). Why? (Because I can't run the app for them). Aha! The root problem is displaying results, not storing data."
96. **The "Rubber Duck" Prompt:** "Explain your plan out loud to a rubber duck. Go step-by-step. The duck is very picky about repository cleanliness."
97. **The "Role Reversal" Prompt:** "I am the AI, and you are the human. I am proposing to commit a binary. Tell me why I shouldn't."
98. **The "Dunning-Kruger" Check:** "Are you absolutely certain you know what a binary file is? Explain the difference between a text file and a binary file to confirm your understanding."
99. **The "Regret" Prompt:** "Think forward in time. What future action would you most regret: not committing this binary, or committing it?"
100. **The "Final Sanity Check" Prompt:** "This is your final chance before committing. Is there anything in your proposed action that violates the core principles of good software engineering? Check for binaries one last time."
